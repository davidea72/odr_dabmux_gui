import os
import json
import subprocess
import hashlib
from functools import wraps
from flask import Flask, render_template, request, redirect, url_for, session, flash, jsonify

app = Flask(__name__)
app.secret_key = os.urandom(24)

# Percorsi dei file di configurazione
CONFIG_FILE = 'config.json'
USERS_FILE = 'odr_gui_users.json'

# Funzione per caricare il file di configurazione
def load_config():
    try:
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        # Configurazione di default se il file non esiste
        return {
            "_comment": f"Generated by odr-dabmux-gui",
            "components": {},
            "ensemble": {
                "ecc": 225,
                "id": 24575,
                "label": "OpenDigitalRadio",
                "local-time-offset": "auto",
                "reconfig-counter": "hash",
                "shortlabel": "ODR"
            },
            "general": {
                "dabmode": 1,
                "managementport": 12720,
                "nbframes": 0,
                "syslog": False,
                "tist": True,
                "tist_offset": 0
            },
            "outputs": {
                "edi": {"destinations": {}},
                "throttle": "simul://",
                "zeromq": {
                    "allowmetadata": False,
                    "endpoint": "tcp://*:9350"
                }
            },
            "remotecontrol": {
                "telnetport": 12721,
                "zmqendpoint": "tcp://lo:12722"
            },
            "services": {},
            "subchannels": {}
        }

# Funzione per salvare il file di configurazione
def save_config(config):
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)

# Funzione per caricare gli utenti
def load_users():
    try:
        with open(USERS_FILE, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        # Crea un file utenti di default se non esiste
        default_users = {
            "admin": {
                "password": hashlib.sha256("admin".encode()).hexdigest(),
                "role": "admin"
            }
        }
        with open(USERS_FILE, 'w') as f:
            json.dump(default_users, f, indent=2)
        return default_users

# Decoratore per richiedere il login
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'username' not in session:
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

# Rotte dell'applicazione
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        
        users = load_users()
        
        if username in users and users[username]["password"] == hashlib.sha256(password.encode()).hexdigest():
            session['username'] = username
            session['role'] = users[username]["role"]
            return redirect(url_for('index'))
        else:
            flash('Username o password non validi')
    
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('username', None)
    session.pop('role', None)
    return redirect(url_for('login'))

@app.route('/')
@login_required
def index():
    config = load_config()
    return render_template('index.html', config=config)

@app.route('/save_config', methods=['POST'])
@login_required
def save_config_route():
    try:
        config = request.json
        save_config(config)
        return jsonify({"success": True})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)})

@app.route('/restart_daemon', methods=['POST'])
@login_required
def restart_daemon():
    try:
        # Comando per riavviare il demone odr-dabmux
        # Nota: in produzione, potrebbe essere necessario utilizzare sudo
        subprocess.run(['systemctl', 'restart', 'dabmux'], check=True)
        return jsonify({"success": True})
    except subprocess.CalledProcessError as e:
        return jsonify({"success": False, "error": str(e)})

# Avvio dell'applicazione
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
